package php.extension.generator

import php.extension.dsl.*

class CGenerator : FileGenerator {
    override val fileName = "extension.c"

    override fun generate(ext: Extension): String = cFileTemplate.fill(
            "version" to ext.version,
            "extName" to ext.name,
            "iniEntries" to ext.ini.joinToString("\n") { iniEntry(it) },
            "argInfoBlock" to argInfoBlock(),
            "zendFunctionEntries" to ext.functions.joinToString("\n    ") { functionEntry.fill("name" to it.name) },//TODO NULL to argInfo
            "constants" to constantsBlock(ext.constants),
            "funcDefinitionBlock" to ext.functions.joinToString("\n") { funcDefinition(it) }
    )

    private fun iniEntry(ini: Ini) = cIniEntry.fill(
            "name" to ini.name,
            "default" to ini.default
    )

    private fun argInfoBlock() = ""  //TODO

    private fun funcDefinition(func: Function) = functionDefinition.fill(
            "name" to func.name,
            "vars" to func.arguments.joinToString("\n    ") { CTmpl.varDeclaration(it.type, it.name) },
            "argsParser" to argsParser(func.arguments),
            "return" to CTmpl.functionReturn(func.returnType, callString(func))
    )

    private fun argsParser(args: List<Argument>) = when {
        args.size > 0 -> argsParser.fill(
                "args" to argsString(args),
                "vars" to args.joinToString(", ") { CTmpl.parserArgument(it.type, it.name) }
        )
        else -> ""
    }

    private fun argsString(args: List<Argument>) = args.joinToString("") {
        (if (it.firstOptional) "|" else "") + it.type.code
    }

    private fun callString(func: Function) = kotlinFuncCall.fill(
            "name" to func.name,
            "args" to callArguments(func.arguments)
    )

    private fun callArguments(args: List<Argument>) = args.joinToString(", ") {
        when (it.type) {
            ArgumentType.NULL -> ""
            else -> "${it.name}"
        }
    }

    private fun constantsBlock(constants: List<Constant>) = constants
            .filterNot { it.type == ArgumentType.NULL }
            .joinToString("\n    ") {
                cConstEntry.fill(
                        "type" to CTmpl.constantTypeDefinition(it),
                        "name" to it.name,
                        "value" to it.getValue()
                )
            }
}

const val cFileTemplate = """//Autogenerated from konfigure.kt
#include "php.h"
#include "extension_kt_api.h"

PHP_INI_BEGIN()
{iniEntries}
PHP_INI_END()

{argInfoBlock}

PHP_MINIT_FUNCTION({extName})
{
    REGISTER_INI_ENTRIES();
    {constants}
    return SUCCESS;
}

{funcDefinitionBlock}

PHP_MSHUTDOWN_FUNCTION({extName})
{
    UNREGISTER_INI_ENTRIES();
    return SUCCESS;
}

PHP_MINFO_FUNCTION({extName}){
    DISPLAY_INI_ENTRIES();
}

static zend_function_entry {extName}_functions[] = {
    {zendFunctionEntries}
    {NULL,NULL,NULL}
};

zend_module_entry {extName}_module_entry = {
#if ZEND_MODULE_API_NO >= 20010901
        STANDARD_MODULE_HEADER,
#endif
        "{extName}",
        {extName}_functions,
        PHP_MINIT({extName}),
        PHP_MSHUTDOWN({extName}),
        NULL,
        NULL,
        PHP_MINFO({extName}),
#if ZEND_MODULE_API_NO >= 20010901
        "{version}",
#endif
        STANDARD_MODULE_PROPERTIES
};
ZEND_GET_MODULE({extName})
"""

const val cIniEntry = """PHP_INI_ENTRY("{name}", "{default}", PHP_INI_ALL, NULL)"""

const val functionEntry = "PHP_FE({name}, NULL)"

const val functionDefinition = """
PHP_FUNCTION({name}){
    {vars}
    {argsParser}
    {return}
}
"""

const val kotlinFuncCall = "extension_kt_symbols()->kotlin.root.{name}({args})"

const val cConstEntry = """{type}("{name}", {value}, CONST_CS|CONST_PERSISTENT);"""

/*
 * Nikolay Igotti [JB]
 * it’s likely K/N  bug, in `CreateCStringFromString`, combined with different behavior
 * of `strlen` with null arg. Pass “” for now, we will fix it.
 */
const val charDeclaration = """
    char *{name} = malloc(1);
    {name}[0] = '\0';
    size_t {name}_len=0;
"""

const val charParserArgument = "&{name}, &{name}_len"
/* ----------------------------------------------------------------------- */

const val argsParser = """
if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "{args}", {vars}) == FAILURE) {
        return;
    }
"""

object CTmpl {
    fun varDeclaration(type: ArgumentType, name: String) = when (type) {
        ArgumentType.LONG -> "zend_long ${name};"
        ArgumentType.DOUBLE -> "double ${name};"
        ArgumentType.STRING -> charDeclaration.fill("name" to name)
        ArgumentType.BOOL -> "zend_bool ${name};"
        ArgumentType.NULL -> ""
    }

    fun constantTypeDefinition(const: Constant) = when (const.type) {
        ArgumentType.LONG -> "REGISTER_LONG_CONSTANT"
        ArgumentType.DOUBLE -> "REGISTER_DOUBLE_CONSTANT"
        ArgumentType.STRING -> "REGISTER_STRING_CONSTANT"
        ArgumentType.BOOL -> "REGISTER_BOOL_CONSTANT"
        ArgumentType.NULL -> "//"
    }

    fun functionReturn(type: ArgumentType, call: String) = when (type) {
        ArgumentType.LONG -> "RETURN_LONG(${call});"
        ArgumentType.DOUBLE -> "RETURN_DOUBLE(${call});"
        ArgumentType.STRING -> "RETURN_STRING(${call});"
        ArgumentType.BOOL -> "RETURN_BOOL(${call});"
        ArgumentType.NULL -> "${call};\n    RETURN_NULL();"
    }

    fun parserArgument(type: ArgumentType, name: String) = when (type) {
        ArgumentType.LONG, ArgumentType.DOUBLE, ArgumentType.BOOL -> "&${name}"
        ArgumentType.STRING -> charParserArgument.fill("name" to name)
        ArgumentType.NULL -> ""
    }
}