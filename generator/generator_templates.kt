package php.extension.generator

import php.extension.dsl.*

fun String.fill(vararg map: Pair<String, String>): String {
    var out = this
    map.forEach { out = out.replace("{${it.first}}", it.second) }
    return out
}

val m4FileTemplate = """
PHP_ARG_ENABLE({name}, whether to enable {name} support,[ --enable-{name}   Enable {name} support])

if test "${'$'}PHP_{upperCaseName}" != "no"; then
    PHP_ADD_INCLUDE(.)
    PHP_ADD_LIBRARY_WITH_PATH(extension_kt, ., {upperCaseName}_SHARED_LIBADD)
    PHP_SUBST({upperCaseName}_SHARED_LIBADD)
    PHP_NEW_EXTENSION({name}, extension.c, ${'$'}ext_shared)
fi
"""

val cFileTemplate = """//Autogenerated from konfigure.kt
#include "php.h"
#include "extension_kt_api.h"

PHP_INI_BEGIN()
{iniEntries}
PHP_INI_END()

{argInfoBlock}

PHP_MINIT_FUNCTION({extName})
{
    REGISTER_INI_ENTRIES();
    {constants}
    return SUCCESS;
}

{funcDefinitionBlock}

PHP_MSHUTDOWN_FUNCTION({extName})
{
    UNREGISTER_INI_ENTRIES();
    return SUCCESS;
}

PHP_MINFO_FUNCTION({extName}){
    DISPLAY_INI_ENTRIES();
}

static zend_function_entry {extName}_functions[] = {
    {zendFunctionEntries}
    {NULL,NULL,NULL}
};

zend_module_entry {extName}_module_entry = {
#if ZEND_MODULE_API_NO >= 20010901
        STANDARD_MODULE_HEADER,
#endif
        "{extName}",
        {extName}_functions,
        PHP_MINIT({extName}),
        PHP_MSHUTDOWN({extName}),
        NULL,
        NULL,
        PHP_MINFO({extName}),
#if ZEND_MODULE_API_NO >= 20010901
        "{version}",
#endif
        STANDARD_MODULE_PROPERTIES
};
ZEND_GET_MODULE({extName})
"""

val cIniEntry = """PHP_INI_ENTRY("{name}", "{default}", PHP_INI_ALL, NULL)"""

val functionEntry = "PHP_FE({name}, NULL)"

val functionDefinition = """
PHP_FUNCTION({name}){
    {vars}
    {argsParser}
    {return}
}
"""

val kotlinFuncCall = "extension_kt_symbols()->kotlin.root.{name}({args})"

val cConstEntry = """{type}("{name}", {value}, CONST_CS|CONST_PERSISTENT);"""

val ktConstEntry = "const val {name} = {value}"

/*
 * Nikolay Igotti [JB]
 * it’s likely K/N  bug, in `CreateCStringFromString`, combined with different behavior
 * of `strlen` with null arg. Pass “” for now, we will fix it.
 */
val charDeclaration = """
    char *{name} = malloc(1);
    {name}[0] = '\0';
    size_t {name}_len=0;
"""

val charParserArgument = "&{name}, &{name}_len"
/* ----------------------------------------------------------------------- */

val argsParser = """
if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "{args}", {vars}) == FAILURE) {
        return;
    }
"""

object Tmpl {
    fun varDeclaration(type: ArgumentType, name: String) = when (type) {
        ArgumentType.LONG -> "zend_long ${name};"
        ArgumentType.DOUBLE -> "double ${name};"
        ArgumentType.STRING -> charDeclaration.fill("name" to name)
        ArgumentType.BOOL -> "zend_bool ${name};"
        ArgumentType.NULL -> ""
    }

    fun constantTypeDefinition(const: Constant) = when (const.type) {
        ArgumentType.LONG -> "REGISTER_LONG_CONSTANT"
        ArgumentType.DOUBLE -> "REGISTER_DOUBLE_CONSTANT"
        ArgumentType.STRING -> "REGISTER_STRING_CONSTANT"
        ArgumentType.BOOL -> "REGISTER_BOOL_CONSTANT"
        ArgumentType.NULL -> "//"
    }

    fun functionReturn(type: ArgumentType, call: String) = when (type) {
        ArgumentType.LONG -> "RETURN_LONG(${call});"
        ArgumentType.DOUBLE -> "RETURN_DOUBLE(${call});"
        ArgumentType.STRING -> "RETURN_STRING(${call});"
        ArgumentType.BOOL -> "RETURN_BOOL(${call});"
        ArgumentType.NULL -> "${call};\n    RETURN_NULL();"
    }

    fun parserArgument(type: ArgumentType, name: String) = when (type) {
        ArgumentType.LONG, ArgumentType.DOUBLE, ArgumentType.BOOL -> "&${name}"
        ArgumentType.STRING -> charParserArgument.fill("name" to name)
        ArgumentType.NULL -> ""
    }
}